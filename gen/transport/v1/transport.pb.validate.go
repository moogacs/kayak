// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/transport/v1/transport.proto

package transportv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RPCHeader with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RPCHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RPCHeader with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RPCHeaderMultiError, or nil
// if none found.
func (m *RPCHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *RPCHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProtocolVersion

	// no validation rules for Id

	// no validation rules for Addr

	if len(errors) > 0 {
		return RPCHeaderMultiError(errors)
	}

	return nil
}

// RPCHeaderMultiError is an error wrapping multiple validation errors returned
// by RPCHeader.ValidateAll() if the designated constraints aren't met.
type RPCHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RPCHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RPCHeaderMultiError) AllErrors() []error { return m }

// RPCHeaderValidationError is the validation error returned by
// RPCHeader.Validate if the designated constraints aren't met.
type RPCHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RPCHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RPCHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RPCHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RPCHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RPCHeaderValidationError) ErrorName() string { return "RPCHeaderValidationError" }

// Error satisfies the builtin error interface
func (e RPCHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRPCHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RPCHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RPCHeaderValidationError{}

// Validate checks the field values on Log with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Log) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Log with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LogMultiError, or nil if none found.
func (m *Log) ValidateAll() error {
	return m.validate(true)
}

func (m *Log) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	// no validation rules for Term

	// no validation rules for Type

	// no validation rules for Data

	// no validation rules for Extensions

	if all {
		switch v := interface{}(m.GetAppendedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogValidationError{
					field:  "AppendedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogValidationError{
					field:  "AppendedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAppendedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogValidationError{
				field:  "AppendedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogMultiError(errors)
	}

	return nil
}

// LogMultiError is an error wrapping multiple validation errors returned by
// Log.ValidateAll() if the designated constraints aren't met.
type LogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogMultiError) AllErrors() []error { return m }

// LogValidationError is the validation error returned by Log.Validate if the
// designated constraints aren't met.
type LogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogValidationError) ErrorName() string { return "LogValidationError" }

// Error satisfies the builtin error interface
func (e LogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogValidationError{}

// Validate checks the field values on AppendEntriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppendEntriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppendEntriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppendEntriesRequestMultiError, or nil if none found.
func (m *AppendEntriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendEntriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRpcHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppendEntriesRequestValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppendEntriesRequestValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRpcHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppendEntriesRequestValidationError{
				field:  "RpcHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Term

	// no validation rules for Leader

	// no validation rules for PrevLogEntry

	// no validation rules for PrevLogTerm

	for idx, item := range m.GetEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AppendEntriesRequestValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AppendEntriesRequestValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AppendEntriesRequestValidationError{
					field:  fmt.Sprintf("Entries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for LeaderCommitIndex

	if len(errors) > 0 {
		return AppendEntriesRequestMultiError(errors)
	}

	return nil
}

// AppendEntriesRequestMultiError is an error wrapping multiple validation
// errors returned by AppendEntriesRequest.ValidateAll() if the designated
// constraints aren't met.
type AppendEntriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendEntriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendEntriesRequestMultiError) AllErrors() []error { return m }

// AppendEntriesRequestValidationError is the validation error returned by
// AppendEntriesRequest.Validate if the designated constraints aren't met.
type AppendEntriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendEntriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppendEntriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppendEntriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppendEntriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppendEntriesRequestValidationError) ErrorName() string {
	return "AppendEntriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AppendEntriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendEntriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendEntriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendEntriesRequestValidationError{}

// Validate checks the field values on AppendEntriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AppendEntriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AppendEntriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AppendEntriesResponseMultiError, or nil if none found.
func (m *AppendEntriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AppendEntriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRpcHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AppendEntriesResponseValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AppendEntriesResponseValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRpcHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AppendEntriesResponseValidationError{
				field:  "RpcHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Term

	// no validation rules for LastLog

	// no validation rules for Success

	// no validation rules for NoRetryBackoff

	if len(errors) > 0 {
		return AppendEntriesResponseMultiError(errors)
	}

	return nil
}

// AppendEntriesResponseMultiError is an error wrapping multiple validation
// errors returned by AppendEntriesResponse.ValidateAll() if the designated
// constraints aren't met.
type AppendEntriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AppendEntriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AppendEntriesResponseMultiError) AllErrors() []error { return m }

// AppendEntriesResponseValidationError is the validation error returned by
// AppendEntriesResponse.Validate if the designated constraints aren't met.
type AppendEntriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AppendEntriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AppendEntriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AppendEntriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AppendEntriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AppendEntriesResponseValidationError) ErrorName() string {
	return "AppendEntriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AppendEntriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAppendEntriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AppendEntriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AppendEntriesResponseValidationError{}

// Validate checks the field values on RequestVoteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RequestVoteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestVoteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestVoteRequestMultiError, or nil if none found.
func (m *RequestVoteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestVoteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRpcHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestVoteRequestValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestVoteRequestValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRpcHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestVoteRequestValidationError{
				field:  "RpcHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Term

	// no validation rules for Candidate

	// no validation rules for LastLogIndex

	// no validation rules for LastLogTerm

	// no validation rules for LeadershipTransfer

	if len(errors) > 0 {
		return RequestVoteRequestMultiError(errors)
	}

	return nil
}

// RequestVoteRequestMultiError is an error wrapping multiple validation errors
// returned by RequestVoteRequest.ValidateAll() if the designated constraints
// aren't met.
type RequestVoteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestVoteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestVoteRequestMultiError) AllErrors() []error { return m }

// RequestVoteRequestValidationError is the validation error returned by
// RequestVoteRequest.Validate if the designated constraints aren't met.
type RequestVoteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestVoteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestVoteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestVoteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestVoteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestVoteRequestValidationError) ErrorName() string {
	return "RequestVoteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RequestVoteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestVoteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestVoteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestVoteRequestValidationError{}

// Validate checks the field values on RequestVoteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RequestVoteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestVoteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestVoteResponseMultiError, or nil if none found.
func (m *RequestVoteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestVoteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRpcHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestVoteResponseValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestVoteResponseValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRpcHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestVoteResponseValidationError{
				field:  "RpcHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Term

	// no validation rules for Peers

	// no validation rules for Granted

	if len(errors) > 0 {
		return RequestVoteResponseMultiError(errors)
	}

	return nil
}

// RequestVoteResponseMultiError is an error wrapping multiple validation
// errors returned by RequestVoteResponse.ValidateAll() if the designated
// constraints aren't met.
type RequestVoteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestVoteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestVoteResponseMultiError) AllErrors() []error { return m }

// RequestVoteResponseValidationError is the validation error returned by
// RequestVoteResponse.Validate if the designated constraints aren't met.
type RequestVoteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestVoteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestVoteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestVoteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestVoteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestVoteResponseValidationError) ErrorName() string {
	return "RequestVoteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RequestVoteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestVoteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestVoteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestVoteResponseValidationError{}

// Validate checks the field values on TimeoutNowRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TimeoutNowRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeoutNowRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TimeoutNowRequestMultiError, or nil if none found.
func (m *TimeoutNowRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeoutNowRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRpcHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeoutNowRequestValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeoutNowRequestValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRpcHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeoutNowRequestValidationError{
				field:  "RpcHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TimeoutNowRequestMultiError(errors)
	}

	return nil
}

// TimeoutNowRequestMultiError is an error wrapping multiple validation errors
// returned by TimeoutNowRequest.ValidateAll() if the designated constraints
// aren't met.
type TimeoutNowRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeoutNowRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeoutNowRequestMultiError) AllErrors() []error { return m }

// TimeoutNowRequestValidationError is the validation error returned by
// TimeoutNowRequest.Validate if the designated constraints aren't met.
type TimeoutNowRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeoutNowRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeoutNowRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeoutNowRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeoutNowRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeoutNowRequestValidationError) ErrorName() string {
	return "TimeoutNowRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TimeoutNowRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeoutNowRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeoutNowRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeoutNowRequestValidationError{}

// Validate checks the field values on TimeoutNowResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TimeoutNowResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeoutNowResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TimeoutNowResponseMultiError, or nil if none found.
func (m *TimeoutNowResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeoutNowResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRpcHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeoutNowResponseValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeoutNowResponseValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRpcHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeoutNowResponseValidationError{
				field:  "RpcHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TimeoutNowResponseMultiError(errors)
	}

	return nil
}

// TimeoutNowResponseMultiError is an error wrapping multiple validation errors
// returned by TimeoutNowResponse.ValidateAll() if the designated constraints
// aren't met.
type TimeoutNowResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeoutNowResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeoutNowResponseMultiError) AllErrors() []error { return m }

// TimeoutNowResponseValidationError is the validation error returned by
// TimeoutNowResponse.Validate if the designated constraints aren't met.
type TimeoutNowResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeoutNowResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeoutNowResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeoutNowResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeoutNowResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeoutNowResponseValidationError) ErrorName() string {
	return "TimeoutNowResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TimeoutNowResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeoutNowResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeoutNowResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeoutNowResponseValidationError{}

// Validate checks the field values on InstallSnapshotRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstallSnapshotRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallSnapshotRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallSnapshotRequestMultiError, or nil if none found.
func (m *InstallSnapshotRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallSnapshotRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRpcHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstallSnapshotRequestValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstallSnapshotRequestValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRpcHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstallSnapshotRequestValidationError{
				field:  "RpcHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SnapshotVersion

	// no validation rules for Term

	// no validation rules for Leader

	// no validation rules for LastLogIndex

	// no validation rules for LastLogTerm

	// no validation rules for Peers

	// no validation rules for Configuration

	// no validation rules for ConfigurationIndex

	// no validation rules for Size

	// no validation rules for Data

	if len(errors) > 0 {
		return InstallSnapshotRequestMultiError(errors)
	}

	return nil
}

// InstallSnapshotRequestMultiError is an error wrapping multiple validation
// errors returned by InstallSnapshotRequest.ValidateAll() if the designated
// constraints aren't met.
type InstallSnapshotRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallSnapshotRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallSnapshotRequestMultiError) AllErrors() []error { return m }

// InstallSnapshotRequestValidationError is the validation error returned by
// InstallSnapshotRequest.Validate if the designated constraints aren't met.
type InstallSnapshotRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallSnapshotRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallSnapshotRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallSnapshotRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallSnapshotRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallSnapshotRequestValidationError) ErrorName() string {
	return "InstallSnapshotRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InstallSnapshotRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallSnapshotRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallSnapshotRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallSnapshotRequestValidationError{}

// Validate checks the field values on InstallSnapshotResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstallSnapshotResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallSnapshotResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallSnapshotResponseMultiError, or nil if none found.
func (m *InstallSnapshotResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallSnapshotResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRpcHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstallSnapshotResponseValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstallSnapshotResponseValidationError{
					field:  "RpcHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRpcHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstallSnapshotResponseValidationError{
				field:  "RpcHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Term

	// no validation rules for Success

	if len(errors) > 0 {
		return InstallSnapshotResponseMultiError(errors)
	}

	return nil
}

// InstallSnapshotResponseMultiError is an error wrapping multiple validation
// errors returned by InstallSnapshotResponse.ValidateAll() if the designated
// constraints aren't met.
type InstallSnapshotResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallSnapshotResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallSnapshotResponseMultiError) AllErrors() []error { return m }

// InstallSnapshotResponseValidationError is the validation error returned by
// InstallSnapshotResponse.Validate if the designated constraints aren't met.
type InstallSnapshotResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallSnapshotResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallSnapshotResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallSnapshotResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallSnapshotResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallSnapshotResponseValidationError) ErrorName() string {
	return "InstallSnapshotResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InstallSnapshotResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallSnapshotResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallSnapshotResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallSnapshotResponseValidationError{}
