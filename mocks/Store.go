// Code generated by mockery v2.36.0. DO NOT EDIT.

package mocks

import (
	context "context"

	kayakv1 "github.com/kayak/gen/proto/kayak/v1"
	mock "github.com/stretchr/testify/mock"

	store "github.com/kayak/internal/store"
)

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

type Store_Expecter struct {
	mock *mock.Mock
}

func (_m *Store) EXPECT() *Store_Expecter {
	return &Store_Expecter{mock: &_m.Mock}
}

// AddRecords provides a mock function with given fields: ctx, topic, records
func (_m *Store) AddRecords(ctx context.Context, topic string, records ...*kayakv1.Record) error {
	_va := make([]interface{}, len(records))
	for _i := range records {
		_va[_i] = records[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, topic)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*kayakv1.Record) error); ok {
		r0 = rf(ctx, topic, records...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_AddRecords_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRecords'
type Store_AddRecords_Call struct {
	*mock.Call
}

// AddRecords is a helper method to define mock.On call
//   - ctx context.Context
//   - topic string
//   - records ...*kayakv1.Record
func (_e *Store_Expecter) AddRecords(ctx interface{}, topic interface{}, records ...interface{}) *Store_AddRecords_Call {
	return &Store_AddRecords_Call{Call: _e.mock.On("AddRecords",
		append([]interface{}{ctx, topic}, records...)...)}
}

func (_c *Store_AddRecords_Call) Run(run func(ctx context.Context, topic string, records ...*kayakv1.Record)) *Store_AddRecords_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*kayakv1.Record, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*kayakv1.Record)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *Store_AddRecords_Call) Return(_a0 error) *Store_AddRecords_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_AddRecords_Call) RunAndReturn(run func(context.Context, string, ...*kayakv1.Record) error) *Store_AddRecords_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function with given fields:
func (_m *Store) Close() {
	_m.Called()
}

// Store_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Store_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Store_Expecter) Close() *Store_Close_Call {
	return &Store_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Store_Close_Call) Run(run func()) *Store_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Store_Close_Call) Return() *Store_Close_Call {
	_c.Call.Return()
	return _c
}

func (_c *Store_Close_Call) RunAndReturn(run func()) *Store_Close_Call {
	_c.Call.Return(run)
	return _c
}

// CommitConsumerPosition provides a mock function with given fields: ctx, topic, consumerGroup, position
func (_m *Store) CommitConsumerPosition(ctx context.Context, topic string, consumerGroup string, position string) error {
	ret := _m.Called(ctx, topic, consumerGroup, position)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, topic, consumerGroup, position)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_CommitConsumerPosition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitConsumerPosition'
type Store_CommitConsumerPosition_Call struct {
	*mock.Call
}

// CommitConsumerPosition is a helper method to define mock.On call
//   - ctx context.Context
//   - topic string
//   - consumerGroup string
//   - position string
func (_e *Store_Expecter) CommitConsumerPosition(ctx interface{}, topic interface{}, consumerGroup interface{}, position interface{}) *Store_CommitConsumerPosition_Call {
	return &Store_CommitConsumerPosition_Call{Call: _e.mock.On("CommitConsumerPosition", ctx, topic, consumerGroup, position)}
}

func (_c *Store_CommitConsumerPosition_Call) Run(run func(ctx context.Context, topic string, consumerGroup string, position string)) *Store_CommitConsumerPosition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *Store_CommitConsumerPosition_Call) Return(_a0 error) *Store_CommitConsumerPosition_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_CommitConsumerPosition_Call) RunAndReturn(run func(context.Context, string, string, string) error) *Store_CommitConsumerPosition_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTopic provides a mock function with given fields: ctx, name
func (_m *Store) CreateTopic(ctx context.Context, name string) error {
	ret := _m.Called(ctx, name)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_CreateTopic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTopic'
type Store_CreateTopic_Call struct {
	*mock.Call
}

// CreateTopic is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Store_Expecter) CreateTopic(ctx interface{}, name interface{}) *Store_CreateTopic_Call {
	return &Store_CreateTopic_Call{Call: _e.mock.On("CreateTopic", ctx, name)}
}

func (_c *Store_CreateTopic_Call) Run(run func(ctx context.Context, name string)) *Store_CreateTopic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Store_CreateTopic_Call) Return(_a0 error) *Store_CreateTopic_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_CreateTopic_Call) RunAndReturn(run func(context.Context, string) error) *Store_CreateTopic_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTopic provides a mock function with given fields: ctx, topic, force
func (_m *Store) DeleteTopic(ctx context.Context, topic string, force bool) error {
	ret := _m.Called(ctx, topic, force)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = rf(ctx, topic, force)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Store_DeleteTopic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTopic'
type Store_DeleteTopic_Call struct {
	*mock.Call
}

// DeleteTopic is a helper method to define mock.On call
//   - ctx context.Context
//   - topic string
//   - force bool
func (_e *Store_Expecter) DeleteTopic(ctx interface{}, topic interface{}, force interface{}) *Store_DeleteTopic_Call {
	return &Store_DeleteTopic_Call{Call: _e.mock.On("DeleteTopic", ctx, topic, force)}
}

func (_c *Store_DeleteTopic_Call) Run(run func(ctx context.Context, topic string, force bool)) *Store_DeleteTopic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *Store_DeleteTopic_Call) Return(_a0 error) *Store_DeleteTopic_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_DeleteTopic_Call) RunAndReturn(run func(context.Context, string, bool) error) *Store_DeleteTopic_Call {
	_c.Call.Return(run)
	return _c
}

// GetConsumerPosition provides a mock function with given fields: ctx, topic, group
func (_m *Store) GetConsumerPosition(ctx context.Context, topic string, group string) (string, error) {
	ret := _m.Called(ctx, topic, group)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, topic, group)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, topic, group)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, topic, group)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetConsumerPosition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConsumerPosition'
type Store_GetConsumerPosition_Call struct {
	*mock.Call
}

// GetConsumerPosition is a helper method to define mock.On call
//   - ctx context.Context
//   - topic string
//   - group string
func (_e *Store_Expecter) GetConsumerPosition(ctx interface{}, topic interface{}, group interface{}) *Store_GetConsumerPosition_Call {
	return &Store_GetConsumerPosition_Call{Call: _e.mock.On("GetConsumerPosition", ctx, topic, group)}
}

func (_c *Store_GetConsumerPosition_Call) Run(run func(ctx context.Context, topic string, group string)) *Store_GetConsumerPosition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Store_GetConsumerPosition_Call) Return(_a0 string, _a1 error) *Store_GetConsumerPosition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetConsumerPosition_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *Store_GetConsumerPosition_Call {
	_c.Call.Return(run)
	return _c
}

// GetRecords provides a mock function with given fields: ctx, topic, start, limit
func (_m *Store) GetRecords(ctx context.Context, topic string, start string, limit int) ([]*kayakv1.Record, error) {
	ret := _m.Called(ctx, topic, start, limit)

	var r0 []*kayakv1.Record
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) ([]*kayakv1.Record, error)); ok {
		return rf(ctx, topic, start, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) []*kayakv1.Record); ok {
		r0 = rf(ctx, topic, start, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*kayakv1.Record)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int) error); ok {
		r1 = rf(ctx, topic, start, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_GetRecords_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRecords'
type Store_GetRecords_Call struct {
	*mock.Call
}

// GetRecords is a helper method to define mock.On call
//   - ctx context.Context
//   - topic string
//   - start string
//   - limit int
func (_e *Store_Expecter) GetRecords(ctx interface{}, topic interface{}, start interface{}, limit interface{}) *Store_GetRecords_Call {
	return &Store_GetRecords_Call{Call: _e.mock.On("GetRecords", ctx, topic, start, limit)}
}

func (_c *Store_GetRecords_Call) Run(run func(ctx context.Context, topic string, start string, limit int)) *Store_GetRecords_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *Store_GetRecords_Call) Return(_a0 []*kayakv1.Record, _a1 error) *Store_GetRecords_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_GetRecords_Call) RunAndReturn(run func(context.Context, string, string, int) ([]*kayakv1.Record, error)) *Store_GetRecords_Call {
	_c.Call.Return(run)
	return _c
}

// Impl provides a mock function with given fields:
func (_m *Store) Impl() interface{} {
	ret := _m.Called()

	var r0 interface{}
	if rf, ok := ret.Get(0).(func() interface{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Store_Impl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Impl'
type Store_Impl_Call struct {
	*mock.Call
}

// Impl is a helper method to define mock.On call
func (_e *Store_Expecter) Impl() *Store_Impl_Call {
	return &Store_Impl_Call{Call: _e.mock.On("Impl")}
}

func (_c *Store_Impl_Call) Run(run func()) *Store_Impl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Store_Impl_Call) Return(_a0 interface{}) *Store_Impl_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_Impl_Call) RunAndReturn(run func() interface{}) *Store_Impl_Call {
	_c.Call.Return(run)
	return _c
}

// ListTopics provides a mock function with given fields: ctx
func (_m *Store) ListTopics(ctx context.Context) ([]string, error) {
	ret := _m.Called(ctx)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Store_ListTopics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTopics'
type Store_ListTopics_Call struct {
	*mock.Call
}

// ListTopics is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Store_Expecter) ListTopics(ctx interface{}) *Store_ListTopics_Call {
	return &Store_ListTopics_Call{Call: _e.mock.On("ListTopics", ctx)}
}

func (_c *Store_ListTopics_Call) Run(run func(ctx context.Context)) *Store_ListTopics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Store_ListTopics_Call) Return(_a0 []string, _a1 error) *Store_ListTopics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Store_ListTopics_Call) RunAndReturn(run func(context.Context) ([]string, error)) *Store_ListTopics_Call {
	_c.Call.Return(run)
	return _c
}

// SnapshotItems provides a mock function with given fields:
func (_m *Store) SnapshotItems() <-chan store.DataItem {
	ret := _m.Called()

	var r0 <-chan store.DataItem
	if rf, ok := ret.Get(0).(func() <-chan store.DataItem); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan store.DataItem)
		}
	}

	return r0
}

// Store_SnapshotItems_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SnapshotItems'
type Store_SnapshotItems_Call struct {
	*mock.Call
}

// SnapshotItems is a helper method to define mock.On call
func (_e *Store_Expecter) SnapshotItems() *Store_SnapshotItems_Call {
	return &Store_SnapshotItems_Call{Call: _e.mock.On("SnapshotItems")}
}

func (_c *Store_SnapshotItems_Call) Run(run func()) *Store_SnapshotItems_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Store_SnapshotItems_Call) Return(_a0 <-chan store.DataItem) *Store_SnapshotItems_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_SnapshotItems_Call) RunAndReturn(run func() <-chan store.DataItem) *Store_SnapshotItems_Call {
	_c.Call.Return(run)
	return _c
}

// Stats provides a mock function with given fields:
func (_m *Store) Stats() map[string]*kayakv1.TopicMetadata {
	ret := _m.Called()

	var r0 map[string]*kayakv1.TopicMetadata
	if rf, ok := ret.Get(0).(func() map[string]*kayakv1.TopicMetadata); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*kayakv1.TopicMetadata)
		}
	}

	return r0
}

// Store_Stats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stats'
type Store_Stats_Call struct {
	*mock.Call
}

// Stats is a helper method to define mock.On call
func (_e *Store_Expecter) Stats() *Store_Stats_Call {
	return &Store_Stats_Call{Call: _e.mock.On("Stats")}
}

func (_c *Store_Stats_Call) Run(run func()) *Store_Stats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Store_Stats_Call) Return(_a0 map[string]*kayakv1.TopicMetadata) *Store_Stats_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Store_Stats_Call) RunAndReturn(run func() map[string]*kayakv1.TopicMetadata) *Store_Stats_Call {
	_c.Call.Return(run)
	return _c
}

// NewStore creates a new instance of Store. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *Store {
	mock := &Store{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
